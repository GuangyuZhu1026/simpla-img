<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../simpla-styles/simpla-styles.html">
<link rel="import" href="../iron-iconset-svg/iron-iconset-svg.html">
<link rel="import" href="../iron-icon/iron-icon.html" async>
<link rel="import" href="../paper-slider/paper-slider.html" async>

<!-- Material icons cherry picked from iron-icons -->
<iron-iconset-svg name="simpla-img">
  <svg>
    <defs>
      <g id="camera-alt"><circle cx="12" cy="12" r="3.2"/><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/></g>
      <g id="title"><path d="M5 4v3h5.5v12h3V7H19V4z"/></g>
    </defs>
  </svg>
</iron-iconset-svg>

<dom-module id="simpla-img-editor">
  <template>
    <style>
      /**
       * Basics
       */
      :host, *, *::before, *::after {
        -webkit-box-sizing: border-box;
                box-sizing: border-box;
      }
      :host {
        display: block;
        position: absolute;
        outline: none;
        font-size: var(--simpla-scale-0);
        z-index: var(--simpla-on-top);
        -webkit-transition: -webkit-box-shadow 130ms var(--simpla-easing-standard),
                    -webkit-transform 200ms var(--simpla-easing-standard);
        transition: -webkit-box-shadow 130ms var(--simpla-easing-standard),
                    -webkit-transform 200ms var(--simpla-easing-standard);
        transition: box-shadow 130ms var(--simpla-easing-standard),
                    transform 200ms var(--simpla-easing-standard);
        transition: box-shadow 130ms var(--simpla-easing-standard),
                    transform 200ms var(--simpla-easing-standard),
                    -webkit-box-shadow 130ms var(--simpla-easing-standard),
                    -webkit-transform 200ms var(--simpla-easing-standard);
      }
      :host([hidden])) {
        display: none;
      }
      :host([visible]) {
        -webkit-box-shadow: var(--simpla-elevation-1);
                box-shadow: var(--simpla-elevation-1);
      }
      .editor {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: var(--simpla-light-white);
      }
      /* Vendor overwrites */
      .cropper-view-box {
        outline: none;
      }
      .cropper-face {
        opacity: 0;
      }
      .cropper-point,
      .cropper-line {
        display: none;
      }
      /**
       * Editor controls
       */
      .tools,
      .zoom {
        position: absolute;
        background: var(--simpla-bright-white);
        z-index: 1;
        height: 30px;
        -webkit-transition: -webkit-transform 130ms var(--simpla-easing-decelerate);
        transition: -webkit-transform 130ms var(--simpla-easing-decelerate);
        transition: transform 130ms var(--simpla-easing-decelerate);
        transition: transform 130ms var(--simpla-easing-decelerate), -webkit-transform 130ms var(--simpla-easing-decelerate);
      }
      .tools {
        display: -webkit-box;
        display: flex;
        -webkit-box-align: center;
                align-items: center;
        top: 0;
        right: 7px;
        max-width: 90%;
        border-bottom-left-radius: var(--simpla-border-radius);
        border-bottom-right-radius: var(--simpla-border-radius);
        color: var(--simpla-grey-700);
      }
      .zoom {
        bottom: 0;
        width: 85%;
        left: 0;
        right: 0;
        margin: auto;
        border-top-left-radius: var(--simpla-border-radius);
        border-top-right-radius: var(--simpla-border-radius);
      }
      :host(:not([visible])) .tools,
      :host(:not([visible])) .zoom {
        -webkit-transition-duration: 60ms;
                transition-duration: 60ms;
        -webkit-transition-timing-function: var(--simpla-easing-accelerate);
                transition-timing-function: var(--simpla-easing-accelerate);
      }
      :host(:not([visible])) .zoom {
        -webkit-transform: translateY(100%);
                transform: translateY(100%);
      }
      :host(:not([visible])) .tools {
        -webkit-transform: translateY(-100%);
                transform: translateY(-100%);
      }
      .zoom__slider {
        width: 100%;
        height: 100%;
        cursor: pointer;
        --paper-slider-active-color: var(--simpla-primary-color);
        --paper-slider-container-color: var(--simpla-grey-500);
        --paper-slider-knob-color: var(--simpla-primary-color);
        --paper-slider-knob-start-color: transparent;
        --paper-slider-knob-start-border-color: var(--simpla-grey-700);
      }
      .zoom__disabled {
        display: block;
        text-align: center;
        font-size: var(--simpla-scale-000);
        color: var(--simpla-grey-700);
        padding: 0.5em 0;
        -webkit-user-select: none;
           -moz-user-select: none;
            -ms-user-select: none;
                user-select: none;
      }
      .tools__tool {
        display: inline-block;
        padding: 5px 10px 7px;
        cursor: pointer;
      }
      .tools__tool:hover,
      .tools__tool[data-active] {
        color: var(--simpla-primary-color);
      }
      .tools__tool__icon {
        --iron-icon-width: var(--simpla-scale-0);
        --iron-icon-height: var(--simpla-scale-0);
      }
      /* Title input */
      .title-input {
        font-family: var(--simpla-font-family);
        font-size: var(--simpla-scale-000);
        background: transparent;
        border: none;
        width: 0;
        padding: 0;
        outline: none;
        -webkit-transition: width 150ms var(--simpla-easing-standard),
                    padding-left 150ms var(--simpla-easing-standard);
        transition: width 150ms var(--simpla-easing-standard),
                    padding-left 150ms var(--simpla-easing-standard);
      }
      .title-input::-webkit-input-placeholder {
        color: var(--simpla-grey-700);
      }
      .title-input:-ms-input-placeholder {
        color: var(--simpla-grey-700);
      }
      .title-input::placeholder {
        color: var(--simpla-grey-700);
      }
      .title-input[data-expanded] {
        width: 18em;
        padding-left: 1em;
      }
      /* Editor Image */
      .editor-img {
        vertical-align: bottom;
        -webkit-transform-origin: center;
                transform-origin: center;
        width: inherit;
        height: inherit;
        cursor: move;
      }
      .editor-img[locked] {
        cursor: default;
      }
      /* Patch hidden prop on IE*/
      [hidden] {
        display: none !important;
      }
      /* Disable taps on icons */
      iron-icon {
        pointer-events: none;
      }
    </style>

    <div class="editor">

      <div class="tools" on-transitionend="_hideIfInactive">
        <input type="text" id="title-input" class="title-input" placeholder="Enter a title" value="{{alt::input}}" on-keydown="_closeTitleOnHotkeys" data-expanded$="[[_titleOpen]]">
        <a class="tools__tool" on-tap="_toggleTitle" data-active$="[[_titleOpen]]">
          <iron-icon class="tools__tool__icon" icon="simpla-img:title">
          </iron-icon>
        </a>

        <a class="tools__tool" on-tap="openFilePicker">
          <iron-icon class="tools__tool__icon" icon="simpla-img:camera-alt">
          </iron-icon>
          <input type="file" id="file-input" on-change="_uploadImg" hidden>
        </a>
      </div>

      <img id="source" hidden="[[!src]]" class="editor-img" crossorigin="anonymous" src$="[[src]]" width$="[[width]]" height$="[[height]]" on-track="_dragImage" on-load="_imageLoaded" draggable="false" locked$="[[lockTransform]]">

      <div class="zoom" on-transitionend="_hideIfInactive">
        <paper-slider id="slider" class="zoom__slider" immediate-value="{{zoom}}" value="[[zoom]]" step="0.01" min="1" max="2" hidden$="[[lockTransform]]" no-ink="">
        </paper-slider>
        <span class="zoom__disabled" hidden$="[[!lockTransform]]">
          GIFs cannot be zoomed
        </span>
      </div>
    </div>
  </template>
  <script>(function () {
'use strict';

var DEFAULT_SRC = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAQAAAA3fa6RAAAADklEQVR42mNkAANGCAUAACMAA2w/AMgAAAAASUVORK5CYII=';

var MIN_SIZE = {
  width: 180,
  height: 130
};

var DEFAULT_SCALE = 1;
var DEFAULT_TRANSLATE_X = 0;
var DEFAULT_TRANSLATE_Y = 0;
var RESET_CTX_TRANSFORM = [1, 0, 0, 1, 0, 0];
var PAN_FINISHED = 'pan-finished';

var canvas = document.createElement('canvas');
var ctx = canvas.getContext('2d');

/**
 * Fit a value inside a range
 * @param  {Number} value Value to fit
 * @param  {Object} range Range, has min and max properties
 * @return {Number}       Value, or min if value is below min, or max if value is
 *                          greater than max
 */
function fitInside(value, range) {
  if (value < range.min) {
    return range.min;
  }

  if (value > range.max) {
    return range.max;
  }

  return value;
}

/**
 * Round given number to given precision e.g. round(1.54, 1) === 1.5
 * @param  {Number} number        Number to round
 * @param  {Number} [precision=0] Decimal places to round to
 * @return {Number}               Rounded number
 */
function round(number) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var factor = Math.pow(10, precision);

  // Move decimal back precision places, round, then move decimal to original
  //  position
  return Math.round(number * factor) / factor;
}

/**
 * 	Manipulable img canvas
 * 	emits 'pan-finished'
 */
var Cropper = {
  properties: {
    /**
     * Rendered output img in base64 encoding
     * @type {String}
     */
    output: {
      type: String,
      notify: true
    },

    /**
     * Position of image in x, y coordinates
     * @type {Object}
     */
    position: {
      type: Object,
      value: function value() {
        return { x: 0, y: 0 };
      },
      observer: '_positionChanged',
      notify: true
    },

    /**
     * Duration of render debouncing. Increase for better performance,
     *  decrease for smoother syncing of image data
     * @type {Object}
     */
    debounceDuration: {
      type: Number,
      value: 100
    },

    /**
     * Current transform string being applied to image
     * @type {Object}
     */
    _transform: {
      type: String,
      value: ''
    }
  },

  observers: ['_updateStyles(_transform)', '_debouncedRender(_transform, src)', '_updatePosition(_transform)', '_updateScale(zoom)'],

  attached: function attached() {
    if (this._localDOMReady) {
      this.setScrollDirection('all', this.$.source);
    }
  },


  /**
   * True if local DOM has been prepped and is ready
   * @type {Boolean}
   */
  get _localDOMReady() {
    return !!this.$;
  },

  /**
   * Updates UI with current scale / translateX / translateY
   * will not happen instantly, happens on next animationFrame
   * @return {undefined}
   */
  _paint: function _paint() {
    var _this = this;

    // Cancel the last tick if there is one waiting
    if (this._tick) {
      cancelAnimationFrame(this._tick);
      this._tick = null;
    }

    // The next tick is the requestAnimationFrame result, so it can be cancelled
    this._tick = requestAnimationFrame(function () {
      var scale = _this.scale,
          translateX = _this.translateX,
          translateY = _this.translateY;


      _this._transform = 'scale(' + scale + ') translateX(' + translateX + 'px) translateY(' + translateY + 'px)';
    });
  },
  _updateScale: function _updateScale(zoom) {
    this.scale = zoom;
  },


  /**
   * @type {Number}
   */
  get scale() {
    return this._scale || DEFAULT_SCALE;
  },

  /**
   * @param {Number} value to set scale
   * @type {Number}
   * @return {undefined}
   */
  set scale(value) {
    var min = this.minScale;

    if (value < min) {
      this._scale = round(parseFloat(min), 2);
    } else {
      this._scale = round(parseFloat(value), 2);
    }

    // Trigger a change to translateX / translateY, incase they haven't been
    //  set yet
    this.translateX += 0;
    this.translateY += 0;

    // Trigger a paint
    this._paint();
  },

  /**
   * @type {Number}
   */
  get translateX() {
    return this._translateX || DEFAULT_TRANSLATE_X;
  },

  /**
   * @param {Number} value Value to set translateX
   * @type {Number}
   * @return {undefined}
   */
  set translateX(value) {
    this._translateX = round(fitInside(value, this._bounds.x));
    this._paint();
  },

  /**
   * @type {Number}
   */
  get translateY() {
    return this._translateY || DEFAULT_TRANSLATE_Y;
  },

  /**
   * @param {Number} value Value to set translateY
   * @type {Number}
   * @return {undefined}
   */
  set translateY(value) {
    this._translateY = round(fitInside(value, this._bounds.y));
    this._paint();
  },

  /**
   * @type {Number}
   */
  get minScale() {
    if (!this._localDOMReady) {
      return 1;
    }

    var scaleHeight = this.height / this.$.source.height,
        scaleWidth = this.width / this.$.source.width;

    if (isNaN(scaleHeight) || isNaN(scaleWidth)) {
      return 1;
    }

    // minScale is the smaller of scaleHeight and scaleWidth. Which are the
    //  ratios between this height / width and the native img height / width,
    //  respectively.
    return scaleHeight < scaleWidth ? scaleHeight : scaleWidth;
  },

  /**
   * The allowed bounds that the image can be transformed within, in both the
   * x and y directions
   * @type {Object}
   */
  get _bounds() {
    var getMinAndMax = function getMinAndMax(overflow) {
      return { min: -overflow / 2, max: overflow / 2 };
    },
        overflowX = void 0,
        overflowY = void 0;

    if (!(this._imgWidth && this._width && this._imgHeight && this._height)) {
      return {
        x: { min: Number.NEGATIVE_INFINITY, max: Number.POSITIVE_INFINITY },
        y: { min: Number.NEGATIVE_INFINITY, max: Number.POSITIVE_INFINITY }
      };
    }

    overflowX = this._imgWidth - this._width / this.scale;
    overflowY = this._imgHeight - this._height / this.scale;

    return {
      x: getMinAndMax(overflowX),
      y: getMinAndMax(overflowY)
    };
  },

  /**
   * Reset the internal dimensions to the offsetWidth / offsetHeights of this and
   * the internal img
   * @return {undefined}
   */
  _resetDimensions: function _resetDimensions() {
    if (!this._localDOMReady) {
      return;
    }

    this._width = this.offsetWidth;
    this._height = this.offsetHeight;

    this._imgWidth = this.$.source.offsetWidth;
    this._imgHeight = this.$.source.offsetHeight;
  },


  /**
   * Takes tracking event and updates coordinates.
   * @param {CustomEvent} event Tracking event as specified by polymer
   * @return {undefined}
   */
  _dragImage: function _dragImage(event) {
    var _event$detail = event.detail,
        dx = _event$detail.dx,
        dy = _event$detail.dy,
        ddx = _event$detail.ddx,
        ddy = _event$detail.ddy,
        state = _event$detail.state;


    if (this.lockTransform) {
      return;
    }

    // Only set the bounds on start to reduce calls to getBoundingClientRect
    if (state === 'start') {
      this._resetDimensions();
    }

    // At the start, we want dx incase it traveled. Just a precaution - probably unecessary.
    this.translateX += (state === 'start' ? dx : ddx) / this.scale;
    this.translateY += (state === 'start' ? dy : ddy) / this.scale;

    if (state === 'end') {
      this.fire(PAN_FINISHED);
    }
  },


  /**
   * Called whenever image is loaded, resets the dimensions
   * @return {undefined}
   */
  _imageLoaded: function _imageLoaded() {
    this._resetDimensions();
  },


  /**
   * Update translateX and translateY values with position
   * @param  {Object} position Position with x y coords
   * @return {undefined}
   */
  _positionChanged: function _positionChanged(position) {
    if (position) {
      var x = position.x,
          y = position.y;

      this.translateX = x;
      this.translateY = y;
    }
  },


  /**
   * Update position with current translateX and translateY values
   * @return {undefined}
   */
  _updatePosition: function _updatePosition() {
    this.position = {
      x: this.translateX,
      y: this.translateY
    };
  },


  /**
   * Update the styles with new transform string
   * @param {String} transform Transform CSS String
   * @return {undefined}
   */
  _updateStyles: function _updateStyles(transform) {
    if (this._localDOMReady) {
      this.$.source.style.transform = transform;
    }
  },


  /**
   * Debounces rendering iff the source image is ready to render
   * @return {undefined}
   */
  _debouncedRender: function _debouncedRender() {
    var sourceIsReady = this._localDOMReady && this.$.source.complete && this.$.source.naturalHeight !== 0;

    if (this.lockTransform || !sourceIsReady) {
      return;
    }

    this.debounce('render', this._render, this.debounceDuration);
  },


  /**
   * Render image to output
   * @return {undefined}
   */
  _render: function _render() {
    if (!this._localDOMReady) {
      return;
    }

    var width = this.width,
        height = this.height,
        scale = this.scale,
        translateX = this.translateX,
        translateY = this.translateY,
        _$$source = this.$.source,
        naturalWidth = _$$source.naturalWidth,
        naturalHeight = _$$source.naturalHeight,
        naturalTranslateX = translateX / (width / naturalWidth),
        naturalTranslateY = translateY / (height / naturalHeight),
        getMidpointOf = function getMidpointOf(dimension) {
      return dimension / scale * (1 - scale) / 2;
    },
        output = void 0;

    canvas.width = naturalWidth;
    canvas.height = naturalHeight;

    ctx.setTransform.apply(ctx, RESET_CTX_TRANSFORM);
    ctx.scale(scale, scale);
    ctx.translate(naturalTranslateX, naturalTranslateY);
    ctx.drawImage(this.$.source, getMidpointOf(naturalWidth), getMidpointOf(naturalHeight));

    output = canvas.toDataURL();

    this.output = this.src === DEFAULT_SRC ? DEFAULT_SRC : output;
  }
};

var ExternalListeners = {
  observers: ['_stopEditingOnResize(active)'],

  listeners: {
    'keyup': '_keyupHandler',
    'blur': '_blurHandler'
  },

  /**
   * Go inactive on viewport resize
   * (Since we're fixed width and abspos)
   * @param  {Boolean} active Current value of the active property
   * @return {undefined}
   */
  _stopEditingOnResize: function _stopEditingOnResize(active) {
    var _this = this;

    var exit = function exit() {
      window.removeEventListener('resize', exit);
      _this.active = false;
    };

    if (active) {
      window.addEventListener('resize', exit);
    }
  },
  _keyupHandler: function _keyupHandler(event) {
    var cmdEnter = event.keyCode === 13 && event.metaKey,
        escape = event.keyCode === 27;

    if (cmdEnter || escape) {
      this.active = false;
    }
  },
  _blurHandler: function _blurHandler(event) {
    var _this2 = this;

    var _handleBlurOnChild = void 0;

    if (Polymer.Settings.useShadow) {
      this.active = false;

      // The rest of the function deals with a lovely bug that only happens in
      //  ShadyDOM, so if we've got ShadowDOM, we return and skip the rest
      return;
    }

    _handleBlurOnChild = function handleBlurOnChild(event) {
      var previouslyFocusedNode = event.target,
          newlyFocusedNode = event.relatedTarget,
          thisContains = function thisContains(node) {
        return _this2.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY;
      };

      if (newlyFocusedNode && thisContains(newlyFocusedNode)) {
        newlyFocusedNode.addEventListener('blur', _handleBlurOnChild);
      } else if (_this2 !== newlyFocusedNode) {
        _this2.active = false;
      }

      previouslyFocusedNode.removeEventListener('blur', _handleBlurOnChild);
    };

    _handleBlurOnChild(event);
  }
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var cache = function (store) {
  return {
    get: function get(key) {
      return store[key];
    },
    set: function set(key, value) {
      store[key] = value;
    }
  };
}({});

var ImageHandler = {
  properties: {
    image: {
      type: Object,
      value: null
    }
  },

  observers: ['_updateImageFromActive(active)', '_updateActiveFromImage(image)', '_maybeAskForFilePicker(image)', '_updateImageData(output, alt)', '_debouncedUpdateCache(src, alt, position, lockTransform, zoom)', '_loadDataFromImage(active, image)', '_resizeFromImage(image)'],

  listeners: {
    'opening-filepicker': '_restoreImageFocus',
    'image-uploaded': '_updateImageSrc'
  },

  _resizeFromImage: function _resizeFromImage(image) {
    if (image) {
      _extends(this, this._getImageBounds(image));
    }
  },
  _loadDataFromImage: function _loadDataFromImage(active, image) {
    if (active && image) {
      var _ref = cache.get(this._getImageKey(image)) || {},
          src = _ref.src,
          _ref$alt = _ref.alt,
          alt = _ref$alt === undefined ? '' : _ref$alt,
          _ref$position = _ref.position,
          position = _ref$position === undefined ? { x: 0, y: 0 } : _ref$position,
          _ref$zoom = _ref.zoom,
          zoom = _ref$zoom === undefined ? 1 : _ref$zoom,
          _ref$lockTransform = _ref.lockTransform,
          lockTransform = _ref$lockTransform === undefined ? false : _ref$lockTransform,
          imageData = this._getImageData(image),
          cachedData = { alt: alt, position: position, zoom: zoom };

      if (src) {
        cachedData.src = src;
      }

      // lockTransform is readOnly, so can't use it in the assign
      this._setLockTransform(lockTransform);

      _extends(this, imageData, cachedData);
    }
  },
  _debouncedUpdateCache: function _debouncedUpdateCache(src, alt, position, lockTransform, zoom) {
    var image = this.image;


    if (image) {
      var key = this._getImageKey(image);
      this.debounce('set-cache-' + key, function () {
        cache.set(key, { src: src, alt: alt, position: position, lockTransform: lockTransform, zoom: zoom });
      });
    }
  },
  _updateImageFromActive: function _updateImageFromActive(active) {
    if (!active && this.image) {
      this._closeImage(this.image);
    }
  },
  _updateActiveFromImage: function _updateActiveFromImage(image) {
    this.active = !!image;
  },
  _updateImageData: function _updateImageData(output, alt) {
    if (this.image) {
      this._setImageData(this.image, { output: output, alt: alt });
    }
  },
  _restoreImageFocus: function _restoreImageFocus(event) {
    var _this = this;

    var image = this.image,
        _blurHandler = void 0;

    _blurHandler = function blurHandler() {
      _this.__restoringFocus = true;
      _this._editImage(image);
      _this.__restoringFocus = false;
      _this.removeEventListener('blur', _blurHandler);
    };

    this.addEventListener('blur', _blurHandler);
  },
  _updateImageSrc: function _updateImageSrc() {
    var _this2 = this;

    var image = this.image,
        _updateSize = void 0;

    _updateSize = function updateSize(event) {
      _this2._resizeFromImage(image);
      image.removeEventListener('load', _updateSize);
    };

    image.addEventListener('load', _updateSize);
    this._updateImageData(this.src, this.alt);
  },


  /**
   * Image utilities
   */

  _getImageBounds: function _getImageBounds(image) {
    var _image$getBoundingCli = image.getBoundingClientRect(),
        top = _image$getBoundingCli.top,
        left = _image$getBoundingCli.left,
        width = _image$getBoundingCli.width,
        height = _image$getBoundingCli.height,
        _window = window,
        scrollX = _window.scrollX,
        scrollY = _window.scrollY;

    top += scrollY;
    left += scrollX;

    return { top: top, left: left, width: width, height: height };
  },
  _maybeAskForFilePicker: function _maybeAskForFilePicker(image) {
    if (image && image.src === DEFAULT_SRC && !this.__restoringFocus) {
      this.openFilePicker();
    }
  },
  _getImageData: function _getImageData(image) {
    return { src: image.src, alt: image.alt };
  },
  _setImageData: function _setImageData(image, _ref2) {
    var src = _ref2.output,
        alt = _ref2.alt;

    _extends(image, { src: src, alt: alt });
  },
  _closeImage: function _closeImage(image) {
    image.active = false;
  },
  _getImageKey: function _getImageKey(image) {
    return image.path;
  },
  _editImage: function _editImage(image) {
    image.active = true;
  }
};

var POPOUT_GUTTER = 8;

function getConstraints(dimensions, maxSize, minSize) {
  var width = dimensions.width,
      height = dimensions.height,
      scale = void 0;


  scale = Math.min(1, Math.min(maxSize.width / width, maxSize.height / height));

  if (scale * width < minSize.width || scale * height < minSize.height) {
    scale = Math.max(minSize.width / width, minSize.height / height);
  }

  return { width: Math.round(width * scale), height: Math.round(height * scale) };
}

function getTranslationForPopout(imageRect, window, gutter) {
  var top = imageRect.top,
      left = imageRect.left,
      width = imageRect.width,
      height = imageRect.height,
      right = left + width,
      bottom = top + height,
      translateX = 0,
      translateY = 0,
      boundaries = void 0;


  boundaries = {
    left: window.scrollX + gutter,
    top: window.scrollY + gutter,
    right: window.scrollX + window.innerWidth - gutter,
    bottom: window.scrollY + window.innerHeight - gutter
  };

  if (left < boundaries.left) {
    translateX = boundaries.left - left;
  } else if (right > boundaries.right) {
    translateX = boundaries.right - right;
  }

  if (top < boundaries.top) {
    translateY = boundaries.top - top;
  } else if (bottom > boundaries.bottom) {
    translateY = boundaries.bottom - bottom;
  }

  return { translateY: translateY, translateX: translateX };
}

function getPositionAndScaleForWindow(imageRect, window) {
  var gutter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : POPOUT_GUTTER;
  var minSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MIN_SIZE;

  var maxSize = void 0,
      width = void 0,
      height = void 0,
      translateX = void 0,
      translateY = void 0;

  maxSize = {
    width: window.innerWidth - gutter * 2,
    height: window.innerHeight - gutter * 2
  };

  var _getConstraints = getConstraints(imageRect, maxSize, minSize);

  width = _getConstraints.width;
  height = _getConstraints.height;

  var _getTranslationForPop = getTranslationForPopout({
    top: imageRect.top,
    left: imageRect.left,
    width: width,
    height: height
  }, window, gutter);

  translateX = _getTranslationForPop.translateX;
  translateY = _getTranslationForPop.translateY;


  return { width: width, height: height, translateX: translateX, translateY: translateY };
}

var Viewable = {
  observers: ['_fitIntoVisibleWindow(top, left, width, height, visible)'],

  /**
   * Translates and scales dimensions to fit within the viewport. This means
   *  translating bounds back into viewport and scaling to width and height
   *  if required.
   * @param  {Number} top       Distance from top of viewport in px
   * @param  {Number} left      Distance from left side of viewport in px
   * @param  {Number} width     Width of image in px
   * @param  {Number} height    Height of image in px
   * @param  {Boolean} visible  If image is visible or not
   * @return {undefined}
   */
  _fitIntoVisibleWindow: function _fitIntoVisibleWindow(top, left, width, height, visible) {
    var _this = this;

    if (!visible) {
      this.style.transform = '';
    }

    this.debounce('fit-to-window', function () {
      var rect = { top: top, left: left, width: width, height: height },
          translateX = void 0,
          translateY = void 0,
          popped = void 0;

      var _getPositionAndScaleF = getPositionAndScaleForWindow(rect, window);

      width = _getPositionAndScaleF.width;
      height = _getPositionAndScaleF.height;
      translateX = _getPositionAndScaleF.translateX;
      translateY = _getPositionAndScaleF.translateY;


      _this.width = width;
      _this.height = height;
      _this.style.transform = 'translate(' + translateX + 'px, ' + translateY + 'px)';

      // Popped essentially just means some position has changed
      popped = !!(width !== rect.width || height !== rect.height || translateX || translateY);

      if (popped) {
        _this._closeOnScroll();
      }
    });
  },
  _closeOnScroll: function _closeOnScroll() {
    var _this2 = this;

    var exit = function exit() {
      window.removeEventListener('scroll', exit);
      _this2.active = false;
    };

    // When the editor is focused (on activation), it will sometimes trigger a
    //  'scroll' event as the browser will automatically try scroll to the
    //  focused element. To stop that focus event from closing the editor
    //  straight away, this listener is attached 100ms after the editor is
    //  activated
    this.async(function () {
      return window.addEventListener('scroll', exit);
    }, 100);
  }
};

var TITLE_EXIT_KEYS = [13, 27];

var SimplaImgEditor = function () {
  function SimplaImgEditor() {
    classCallCheck(this, SimplaImgEditor);
  }

  createClass(SimplaImgEditor, [{
    key: 'beforeRegister',
    value: function beforeRegister() {
      this.is = 'simpla-img-editor';

      this.properties = {

        /**
         * State of the editor
         * @type {Boolean}
         */
        active: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * Whether editor is visible
         * Used for CSS transitions
         * @type {Boolean}
         */
        visible: {
          type: Boolean,
          reflectToAttribute: true,
          readonly: true,
          value: false
        },

        /**
         * Whether editor is hidden
         * Used for CSS transitions
         * @type {Boolean}
         */
        hidden: {
          type: Boolean,
          reflectToAttribute: true,
          readonly: true,
          value: true
        },

        /**
         * Image src
         * @type {String}
         */
        src: {
          type: String,
          notify: true
        },

        /**
         * Alt title for the image
         * @type {String}
         */
        alt: {
          type: String,
          notify: true,
          value: ''
        },

        /**
         * Absolute zoom value
         * @type {Number}
         */
        zoom: {
          type: Number,
          notify: true,
          value: 1
        },

        /**
         * Current position of editor image with x y coordinates
         * @type {Object}
         */
        position: {
          type: Object,
          value: function value() {
            return { x: 0, y: 0 };
          }
        },

        /**
         * Width of editor in px
         * @type {Number}
         */
        width: {
          type: Number,
          observer: '_observeWidth'
        },

        /**
         * Height of editor in px
         * @type {Number}
         */
        height: {
          type: Number,
          observer: '_observeHeight'
        },

        /**
         * Top of editor in px
         * @type {Number}
         */
        top: {
          type: Number,
          observer: '_observeTop',
          value: 0
        },

        /**
         * Left of editor in px
         * @type {Number}
         */
        left: {
          type: Number,
          observer: '_observeLeft',
          value: 0
        },

        /**
         * Rendered image of editorin base64 encoding. Property is debounced
         * for performance reasons so isn't a live representation of the canvas.
         * @type {String}
         */
        output: {
          type: String,
          notify: true
        },

        /**
         * Whether the editor canvas is locked
         * @type {Boolean}
         */
        lockTransform: {
          type: Boolean,
          value: false,
          readOnly: true,
          reflectToAttribute: true
        },

        /**
         * Whether title input is expanded
         * @type {Boolean}
         */
        _titleOpen: {
          type: Boolean,
          value: false
        },

        /**
         * Tabindex, used to give editor focus
         * @type {Number}
         */
        tabindex: {
          type: Number,
          reflectToAttribute: true,
          value: 0
        }
      };

      this.observers = ['_toggleVisibility(active)', '_focusOnActive(active)'];
    }
  }, {
    key: 'openFilePicker',


    /**
     * Utility method to open file input
     * @param  {Event} e Tap event from parent control
     * @return {undefined}
     */
    value: function openFilePicker(e) {
      e && e.stopPropagation();
      this.fire('opening-filepicker');
      this.$['file-input'].click();
    }
  }, {
    key: '_observeWidth',
    value: function _observeWidth(width) {
      this.style.width = width + 'px';
    }
  }, {
    key: '_observeHeight',
    value: function _observeHeight(height) {
      this.style.height = height + 'px';
    }
  }, {
    key: '_observeLeft',
    value: function _observeLeft(left) {
      this.style.left = left + 'px';
    }
  }, {
    key: '_observeTop',
    value: function _observeTop(top) {
      this.style.top = top + 'px';
    }

    /**
     * Sets open true if active is true, for transitions
     * @param  {Boolean} active Current value of the active prop
     * @return {undefined}
     */

  }, {
    key: '_toggleVisibility',
    value: function _toggleVisibility(active) {
      var _this = this;

      if (active) {
        this.hidden = false;
        Polymer.RenderStatus.afterNextRender(this, function () {
          return _this.visible = true;
        });
      } else {
        this.visible = false;
      }
    }

    /**
     * Sets active false if open is false, for transitions
     * @param {Event} e Transitionend event
     * @return {undefined}
     */

  }, {
    key: '_hideIfInactive',
    value: function _hideIfInactive(e) {
      if (!this.active) {
        this.hidden = true;

        // Ensure visible false if active changed during transitions
        this.visible = false;
      }
    }

    /**
     * Takes file from file input and sets it to src prop
     * @param  {Event} e Change event from file input
     * @return {undefined}
     */

  }, {
    key: '_uploadImg',
    value: function _uploadImg(e) {
      var _this2 = this;

      var fileInput = e.target,
          files = fileInput.files,
          reader = new FileReader(),
          setFile = function setFile(e) {
        if (files[0].type === 'image/gif') {
          _this2.zoom = 0;
          _this2.position = { x: 0, y: 0 };
          _this2._setLockTransform(true);
        } else {
          _this2._setLockTransform(false);
        }

        _this2.src = e.target.result;
        _this2.fire('image-uploaded', { value: e.target.result });
        reader.removeEventListener('load', setFile);

        // Removes file from file input so that uploading a new file later
        //  with the same name as previous will trigger change
        fileInput.value = null;
      };

      this.focus();

      if (!files || !files[0]) {
        return;
      }

      reader.addEventListener('load', setFile);
      reader.readAsDataURL(files[0]);
    }

    /**
     * Override normal focus to stop scrolling on focus
     * @return {undefined}
     */

  }, {
    key: 'focus',
    value: function focus() {
      var _window = window,
          scrollY = _window.scrollY,
          scrollX = _window.scrollX;

      HTMLElement.prototype.focus.call(this);
      window.scrollTo(scrollX, scrollY);
    }

    /**
     * Utility method to toggle _titleOpen prop
     * @return {undefined}
     */

  }, {
    key: '_toggleTitle',
    value: function _toggleTitle() {
      this._titleOpen = !this._titleOpen;
    }

    /**
     * Autofocus the editor on active
     * @param  {Boolean} active Current value of active prop
     * @return {undefined}
     */

  }, {
    key: '_focusOnActive',
    value: function _focusOnActive(active) {
      var _this3 = this;

      if (active) {
        this.async(function () {
          return _this3.focus();
        }, 0);
      }
    }

    /**
     * Close title input if it receives special keys
     * @param  {Event} e Keyup event from link input
     * @return {undefined}
     */

  }, {
    key: '_closeTitleOnHotkeys',
    value: function _closeTitleOnHotkeys(e) {
      if (TITLE_EXIT_KEYS.indexOf(e.keyCode) !== -1) {
        this._titleOpen = false;
      }
    }
  }, {
    key: 'behaviors',
    get: function get() {
      return [Cropper, ExternalListeners, ImageHandler, Viewable];
    }
  }]);
  return SimplaImgEditor;
}();



Polymer(SimplaImgEditor);

}());
</script>
</dom-module>
